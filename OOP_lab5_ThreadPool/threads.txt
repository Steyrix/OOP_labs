=============PRODUCE============
       std::thread producerThread([this, &fin](){
           T value;
           while(fin >> value && !fileDone){
                numbersQueue.push(value);
           }
           std::cout << "File done. Finishing reading..." << std::endl;
          fileDone = true;
          fin.close();
        });
=============PAUSE=============
        std::thread pauserThread([this, &fout](){
                std::string comm;
                while(!numbersQueue.isEmpty() || !fileDone)
                {
                    std::cin >> comm;
                    if(comm == "pause" && !disabled)
                    {
                        {
                            std::unique_lock<std::mutex> locker (mtx);
                            std::cout << "Pausing..." << std::endl;
                            pause = true;
                            fout.close();
                        }
                        pauseCondition.notify_all();
                    }
                    if(comm == "resume" && !disabled)
                    {
                        {
                            std::unique_lock<std::mutex> locker(mtx);
                            std::cout << "Resuming..." << std::endl;
                            pause = false;
                            fout.open(outputFile, std::ofstream::app);
                        }
                        pauseCondition.notify_all();
                    }
                    if(comm == "exit")
                    {
                        {
                            std::unique_lock<std::mutex> locker(mtx);
                            std::cout << "Exiting..." << std::endl;
                            disabled = true;
                            fileDone = true;
                            pause = false;
                        }
                        pauseCondition.notify_all();
                        break;
                    }
                }

            std::cout << "Pauser thread is finishing..." << std::endl;
        });